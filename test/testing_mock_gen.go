// Code generated by "genmock"; DO NOT EDIT.
// Mock for github.com/kmio11/codegen/test.SomeInterface
package test

import (
	"github.com/kmio11/codegen/test/dummy"
	dummy0 "github.com/kmio11/codegen/test/dummy2"
	"io"
)

type MockSomeInterface struct {
	SomeInterface
	FakeFuncA func(arr [2]string, slice []int, n int, chs <-chan string, chr chan<- int, chrs chan int64, ip *int, v ...string) (map[string]string, error)
	FakeFuncB func(d dummy.Dummy, d2 dummy0.Dummy2, ss SomeStruct, i io.Writer, si SomeInterface, r *dummy.Dummy)
	FakeFuncC func(fn func(a int, b int, c dummy.Dummy) error, n int) (a string, b int)
	FakeFuncD func(i interface{}, ii interface {
		SomeInterface
		Func(x int) int
	}, s struct{}, ss struct {
		dummy.Dummy
		em  dummy0.Dummy2
		str string
	})
	FakeFuncE func(string, string, int)
}

func (m MockSomeInterface) FuncA(a0 [2]string, a1 []int, a2 int, a3 <-chan string, a4 chan<- int, a5 chan int64, a6 *int, a7 ...string) (map[string]string, error) {
	return m.FakeFuncA(a0, a1, a2, a3, a4, a5, a6, a7...)
}

func (m MockSomeInterface) FuncB(a0 dummy.Dummy, a1 dummy0.Dummy2, a2 SomeStruct, a3 io.Writer, a4 SomeInterface, a5 *dummy.Dummy) {
	m.FakeFuncB(a0, a1, a2, a3, a4, a5)
}

func (m MockSomeInterface) FuncC(a0 func(a int, b int, c dummy.Dummy) error, a1 int) (string, int) {
	return m.FakeFuncC(a0, a1)
}

func (m MockSomeInterface) FuncD(a0 interface{}, a1 interface {
	SomeInterface
	Func(x int) int
}, a2 struct{}, a3 struct {
	dummy.Dummy
	em  dummy0.Dummy2
	str string
}) {
	m.FakeFuncD(a0, a1, a2, a3)
}

func (m MockSomeInterface) FuncE(a0 string, a1 string, a2 int) {
	m.FakeFuncE(a0, a1, a2)
}

type StubSomeInterface struct {
	FuncA StubFuncA
	FuncB StubFuncB
	FuncC StubFuncC
	FuncD StubFuncD
	FuncE StubFuncE
}

func (s StubSomeInterface) NewMock() SomeInterface {
	return &MockSomeInterface{FakeFuncA: s.FakeFuncA, FakeFuncB: s.FakeFuncB, FakeFuncC: s.FakeFuncC, FakeFuncD: s.FakeFuncD, FakeFuncE: s.FakeFuncE}
}

func (s StubSomeInterface) FakeFuncA(a0 [2]string, a1 []int, a2 int, a3 <-chan string, a4 chan<- int, a5 chan int64, a6 *int, a7 ...string) (map[string]string, error) {
	return s.FuncA.R0, s.FuncA.R1
}

func (s StubSomeInterface) FakeFuncB(a0 dummy.Dummy, a1 dummy0.Dummy2, a2 SomeStruct, a3 io.Writer, a4 SomeInterface, a5 *dummy.Dummy) {
	return
}

func (s StubSomeInterface) FakeFuncC(a0 func(a int, b int, c dummy.Dummy) error, a1 int) (string, int) {
	return s.FuncC.R0, s.FuncC.R1
}

func (s StubSomeInterface) FakeFuncD(a0 interface{}, a1 interface {
	SomeInterface
	Func(x int) int
}, a2 struct{}, a3 struct {
	dummy.Dummy
	em  dummy0.Dummy2
	str string
}) {
	return
}

func (s StubSomeInterface) FakeFuncE(a0 string, a1 string, a2 int) {
	return
}

type StubFuncA struct {
	R0 map[string]string
	R1 error
}

type StubFuncB struct {
}

type StubFuncC struct {
	R0 string
	R1 int
}

type StubFuncD struct {
}

type StubFuncE struct {
}
