// Code generated by "genmock"; DO NOT EDIT.
// Mock for github.com/kmio11/codegen/test.SomeInterface
package test

import (
	"github.com/kmio11/codegen/test/dummy"
	dummy0 "github.com/kmio11/codegen/test/dummy2"
	"io"
)

type MockSomeInterface struct {
	SomeInterface
	FakeCycle  func(cc CycleStr)
	FakeFuncA  func(arr [2]string, slice []int, n int, chs <-chan string, chr chan<- int, chrs chan int64, ip *int, v ...string) (map[string]string, error)
	FakeFuncB  func(d dummy.Dummy, d2 dummy0.Dummy2, ss SomeStruct, i io.Writer, si SomeInterface, r *dummy.Dummy)
	FakeFuncC  func(fn func(a int, b int, c dummy.Dummy) error, n int) (a string, b int)
	FakeFuncCA func(d SomeStruct, r SomeStruct)
	FakeFuncD  func(i interface{}, ii interface {
		SomeInterface
		Func(x int) int
	}, s struct{}, ss struct {
		dummy.Dummy
		em  dummy0.Dummy2
		str string
	})
	FakeFuncE func(string, string, int)
}

func (m MockSomeInterface) Cycle(a0 CycleStr) {
	m.FakeCycle(a0)
}

func (m MockSomeInterface) FuncA(a0 [2]string, a1 []int, a2 int, a3 <-chan string, a4 chan<- int, a5 chan int64, a6 *int, a7 ...string) (map[string]string, error) {
	return m.FakeFuncA(a0, a1, a2, a3, a4, a5, a6, a7...)
}

func (m MockSomeInterface) FuncB(a0 dummy.Dummy, a1 dummy0.Dummy2, a2 SomeStruct, a3 io.Writer, a4 SomeInterface, a5 *dummy.Dummy) {
	m.FakeFuncB(a0, a1, a2, a3, a4, a5)
}

func (m MockSomeInterface) FuncC(a0 func(a int, b int, c dummy.Dummy) error, a1 int) (string, int) {
	return m.FakeFuncC(a0, a1)
}

func (m MockSomeInterface) FuncCA(a0 SomeStruct, a1 SomeStruct) {
	m.FakeFuncCA(a0, a1)
}

func (m MockSomeInterface) FuncD(a0 interface{}, a1 interface {
	SomeInterface
	Func(x int) int
}, a2 struct{}, a3 struct {
	dummy.Dummy
	em  dummy0.Dummy2
	str string
}) {
	m.FakeFuncD(a0, a1, a2, a3)
}

func (m MockSomeInterface) FuncE(a0 string, a1 string, a2 int) {
	m.FakeFuncE(a0, a1, a2)
}

type StubSomeInterface struct {
	Cycle  StubCycle
	FuncA  StubFuncA
	FuncB  StubFuncB
	FuncC  StubFuncC
	FuncCA StubFuncCA
	FuncD  StubFuncD
	FuncE  StubFuncE
}

func (s StubSomeInterface) NewMock() SomeInterface {
	return &MockSomeInterface{FakeCycle: s.FakeCycle, FakeFuncA: s.FakeFuncA, FakeFuncB: s.FakeFuncB, FakeFuncC: s.FakeFuncC, FakeFuncCA: s.FakeFuncCA, FakeFuncD: s.FakeFuncD, FakeFuncE: s.FakeFuncE}
}

func (s StubSomeInterface) FakeCycle(a0 CycleStr) {
	return
}

func (s StubSomeInterface) FakeFuncA(a0 [2]string, a1 []int, a2 int, a3 <-chan string, a4 chan<- int, a5 chan int64, a6 *int, a7 ...string) (map[string]string, error) {
	return s.FuncA.R0, s.FuncA.R1
}

func (s StubSomeInterface) FakeFuncB(a0 dummy.Dummy, a1 dummy0.Dummy2, a2 SomeStruct, a3 io.Writer, a4 SomeInterface, a5 *dummy.Dummy) {
	return
}

func (s StubSomeInterface) FakeFuncC(a0 func(a int, b int, c dummy.Dummy) error, a1 int) (string, int) {
	return s.FuncC.R0, s.FuncC.R1
}

func (s StubSomeInterface) FakeFuncCA(a0 SomeStruct, a1 SomeStruct) {
	return
}

func (s StubSomeInterface) FakeFuncD(a0 interface{}, a1 interface {
	SomeInterface
	Func(x int) int
}, a2 struct{}, a3 struct {
	dummy.Dummy
	em  dummy0.Dummy2
	str string
}) {
	return
}

func (s StubSomeInterface) FakeFuncE(a0 string, a1 string, a2 int) {
	return
}

type StubCycle struct{}

type StubFuncA struct {
	R0 map[string]string
	R1 error
}

type StubFuncB struct{}

type StubFuncC struct {
	R0 string
	R1 int
}

type StubFuncCA struct{}

type StubFuncD struct{}

type StubFuncE struct{}
