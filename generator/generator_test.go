package generator

import (
	"strings"
	"testing"
)

func TestGenerator(t *testing.T) {
	g := &Generator{}
	
	// Test initial state
	if g.buf.Len() != 0 {
		t.Error("Generator buffer should be empty initially")
	}
}

func TestGeneratorPrintHeader(t *testing.T) {
	g := &Generator{}
	result := g.PrintHeader("test")
	
	if result != g {
		t.Error("PrintHeader should return the same generator instance for chaining")
	}
	
	// Check that header was added to buffer
	content := g.buf.String()
	if !strings.Contains(content, "Code generated by") {
		t.Error("PrintHeader should add header comment")
	}
	
	if !strings.Contains(content, "test") {
		t.Error("PrintHeader should include the command name")
	}
}

func TestGeneratorPrintf(t *testing.T) {
	g := &Generator{}
	testStr := "Hello, %s!"
	
	result := g.Printf(testStr, "World")
	
	if result != g {
		t.Error("Printf should return the same generator instance for chaining")
	}
	
	// Check that content was added to buffer
	content := g.buf.String()
	expected := "Hello, World!"
	if content != expected {
		t.Errorf("Printf() content = %v, want %v", content, expected)
	}
}

func TestGeneratorNewLine(t *testing.T) {
	g := &Generator{}
	result := g.NewLine()
	
	if result != g {
		t.Error("NewLine should return the same generator instance for chaining")
	}
	
	// Check that newline was added
	content := g.buf.String()
	if content != "\n" {
		t.Errorf("NewLine() content = %v, want %v", content, "\n")
	}
}

func TestGeneratorChaining(t *testing.T) {
	g := &Generator{}
	
	// Test method chaining
	result := g.
		PrintHeader("test").
		Printf("package %s", "main").
		NewLine().
		Printf("func main() {").
		NewLine().
		Printf("}")
	
	if result != g {
		t.Error("Method chaining should return the same generator instance")
	}
	
	// Check that all content was added
	content := g.buf.String()
	if !strings.Contains(content, "package main") {
		t.Error("Chained content should contain package declaration")
	}
	
	if !strings.Contains(content, "func main()") {
		t.Error("Chained content should contain function declaration")
	}
}

func TestGeneratorFormat(t *testing.T) {
	g := &Generator{}
	
	// Add some Go code
	g.Printf("package main")
	g.NewLine()
	g.Printf("func main(){}")
	
	// Format the code
	formatted := g.Format()
	
	if len(formatted) == 0 {
		t.Error("Format should return non-empty byte slice")
	}
	
	// Check if the formatted code looks like Go code
	formattedStr := string(formatted)
	if !strings.Contains(formattedStr, "package main") {
		t.Error("Formatted code should contain the original package declaration")
	}
	
	if !strings.Contains(formattedStr, "func main()") {
		t.Error("Formatted code should contain the main function")
	}
	
	// Check that formatting improved the code (added proper spacing)
	if !strings.Contains(formattedStr, "func main() {") {
		t.Error("Formatted code should have proper spacing")
	}
}

func TestGeneratorFormatInvalidCode(t *testing.T) {
	g := &Generator{}
	
	// Add invalid Go code
	g.Printf("invalid go code {{{")
	
	// Format should handle invalid code gracefully
	formatted := g.Format()
	
	if len(formatted) == 0 {
		t.Error("Format should return something even for invalid code")
	}
	
	// Should return original content when formatting fails
	formattedStr := string(formatted)
	if !strings.Contains(formattedStr, "invalid go code {{{") {
		t.Error("Format should return original content when formatting fails")
	}
}

func TestGeneratorFormatComplexCode(t *testing.T) {
	g := &Generator{}
	
	// Generate a more complex Go structure
	g.PrintHeader("test")
	g.Printf("// Mock for test interface")
	g.NewLine()
	g.Printf("package main")
	g.NewLine()
	g.Printf("type MockInterface struct {")
	g.NewLine()
	g.Printf("    FakeMethod func() error")
	g.NewLine()
	g.Printf("}")
	g.NewLine()
	g.Printf("func (m *MockInterface) Method() error {")
	g.NewLine()
	g.Printf("    return m.FakeMethod()")
	g.NewLine()
	g.Printf("}")
	
	formatted := g.Format()
	formattedStr := string(formatted)
	
	// Check for proper formatting
	if !strings.Contains(formattedStr, "type MockInterface struct") {
		t.Error("Formatted code should contain the struct definition")
	}
	
	if !strings.Contains(formattedStr, "func (m *MockInterface) Method()") {
		t.Error("Formatted code should contain the method definition")
	}
	
	// Check that formatting added proper indentation
	lines := strings.Split(formattedStr, "\n")
	structFound := false
	for _, line := range lines {
		if strings.Contains(line, "FakeMethod func()") {
			if !strings.HasPrefix(line, "\t") && !strings.HasPrefix(line, "    ") {
				t.Error("Struct fields should be indented")
			}
			structFound = true
		}
	}
	if !structFound {
		t.Error("Should find properly formatted struct field")
	}
}

func TestGeneratorEmptyFormat(t *testing.T) {
	g := &Generator{}
	
	// Format empty generator
	formatted := g.Format()
	
	// Empty generators return empty byte slice, which is expected
	if len(formatted) == 0 {
		// This is expected behavior
	}
}

func TestGeneratorMultipleFormats(t *testing.T) {
	g := &Generator{}
	
	g.Printf("package main")
	g.NewLine()
	g.Printf("func test() {}")
	
	// Format multiple times should work
	formatted1 := g.Format()
	formatted2 := g.Format()
	
	if len(formatted1) == 0 || len(formatted2) == 0 {
		t.Error("Multiple Format() calls should work")
	}
	
	// Results should be identical
	if string(formatted1) != string(formatted2) {
		t.Error("Multiple Format() calls should return identical results")
	}
}

func TestGeneratorBuildsCorrectGoCode(t *testing.T) {
	g := &Generator{}
	
	// Build a complete Go file
	g.Printf("package test")
	g.NewLine()
	g.NewLine()
	g.Printf("import \"fmt\"")
	g.NewLine()
	g.NewLine()
	g.Printf("type TestStruct struct {")
	g.NewLine()
	g.Printf("\tName string")
	g.NewLine()
	g.Printf("}")
	g.NewLine()
	g.NewLine()
	g.Printf("func (t *TestStruct) GetName() string {")
	g.NewLine()
	g.Printf("\treturn t.Name")
	g.NewLine()
	g.Printf("}")
	
	formatted := g.Format()
	formattedStr := string(formatted)
	
	// Check that all parts are present
	expectedParts := []string{
		"package test",
		"import \"fmt\"",
		"type TestStruct struct",
		"Name string",
		"func (t *TestStruct) GetName() string",
		"return t.Name",
	}
	
	for _, part := range expectedParts {
		if !strings.Contains(formattedStr, part) {
			t.Errorf("Formatted code should contain: %s", part)
		}
	}
}

func TestGeneratorContentAccumulation(t *testing.T) {
	g := &Generator{}
	
	// Add content incrementally
	g.Printf("part1")
	
	if !strings.Contains(g.buf.String(), "part1") {
		t.Error("Buffer should contain first part")
	}
	
	g.Printf("part2")
	
	content := g.buf.String()
	if !strings.Contains(content, "part1part2") {
		t.Error("Buffer should accumulate content")
	}
	
	g.NewLine()
	g.Printf("part3")
	
	finalContent := g.buf.String()
	if !strings.Contains(finalContent, "part1part2\npart3") {
		t.Error("Buffer should contain all parts with newline")
	}
}