package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
)

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
}

// Format generate formatted source code.
func (g *Generator) Format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		log.Printf("warning: invalid code generated: %s", err)
		return g.buf.Bytes()
	}
	return src
}

// Printf formats according to a format specifier and writes to Generator.buf.
func (g *Generator) Printf(format string, args ...interface{}) *Generator {
	fmt.Fprintf(&g.buf, format, args...)
	return g
}

// NewLine insert newline.
func (g *Generator) NewLine() *Generator {
	return g.Printf("\n")
}

// PrintHeader print header.
func (g *Generator) PrintHeader(cmd string) *Generator {
	return g.Printf("// Code generated by \"%s\"; DO NOT EDIT.\n", cmd)
}

// PrintPackage print package.
func (g *Generator) PrintPackage(pkgname string) *Generator {
	return g.Printf(`package %s`, pkgname)
}

// PrintImport print import
func (g *Generator) PrintImport(pkgmap map[string]string) *Generator {
	if len(pkgmap) == 0 {
		return g
	}
	g = g.Printf("import (").NewLine()
	for pkgpath, pkgname := range pkgmap {
		if pkgname == "" {
			g = g.Printf(`"%s"`, pkgpath)
		} else {
			g = g.Printf(`%s "%s"`, pkgname, pkgpath)
		}
		g = g.NewLine()
	}
	g = g.Printf(")").NewLine()

	return g
}
