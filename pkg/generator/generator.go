package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
)

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf      bytes.Buffer // Accumulated output.
	contents []Printer
}

// Printer is interface to print codes.
type Printer interface {
	Print() string
}

// Printf formats according to a format specifier and writes to Generator.buf.
func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// Format generate formatted source code.
func (g *Generator) Format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		log.Printf("warning: invalid code generated: %s", err)
		return g.buf.Bytes()
	}
	return src
}

// NewLine insert newline.
func (g *Generator) NewLine() {
	g.Printf("\n")
}

// PrintHeader print header.
func (g *Generator) PrintHeader(cmd string) {
	g.Printf("// Code generated by \"%s\"; DO NOT EDIT.\n", cmd)
}

// PrintPackage print package.
func (g *Generator) PrintPackage(pkgname string) {
	g.Printf(`package %s`, pkgname)
}

// PrintImport print import
func (g *Generator) PrintImport(pkgmap map[string]string) {
	if len(pkgmap) == 0 {
		return
	}
	g.Printf("import (")
	g.NewLine()
	for pkgpath, pkgname := range pkgmap {
		if pkgname == "" {
			g.Printf(`"%s"`, pkgpath)
		} else {
			g.Printf(`%s "%s"`, pkgname, pkgpath)
		}
		g.NewLine()
	}
	g.Printf(")")
	g.NewLine()
}

// PrintContents print all contents to buf.
func (g *Generator) PrintContents() {
	for _, c := range g.contents {
		g.Printf(c.Print())
	}
	g.contents = []Printer{}
}

// AddContents add contents.
func (g *Generator) AddContents(c ...Printer) {
	g.contents = append(g.contents, c...)
}
